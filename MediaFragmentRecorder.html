<!DOCTYPE html>
<html>
<head>
  <title>Record media fragments to single media file using HTMLMediaElement.captureStream(), MediaStream addtrack event, ImageCapture(), canvas.captureStream(), ReadableStream(), WritableStream(), AudioContext(), MediaRecorder()</title>
</head>
<body>
  <h1 id="click">click</h1>
  <video id="playlist" src="" controls="true" autoplay="true"></video>
  <script>
    (async() => {
      const captureStream = mediaElement =>
        "mozCaptureStream" in mediaElement ? mediaElement.mozCaptureStream() : mediaElement.captureStream();
      const urls = Promise.all([{
        from: 0,
        to: 4,
        src: "https://upload.wikimedia.org/wikipedia/commons/a/a4/Xacti-AC8EX-Sample_video-001.ogv"
      }, {
        from: 10,
        to: 20,
        src: "https://mirrors.creativecommons.org/movingimages/webm/ScienceCommonsJesseDylan_240p.webm#t=10,20"
      }, {
        from: 55,
        to: 60,
        src: "https://nickdesaulniers.github.io/netfix/demo/frag_bunny.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://raw.githubusercontent.com/w3c/web-platform-tests/master/media-source/mp4/test.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4"
      }, {
        from: 0,
        to: 6,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4#t=0,6"
      }].map(async({
        from,
        to,
        src
      }) => {
        try {
          const request = await fetch(src);
          const blob = await request.blob();
          const blobURL = URL.createObjectURL(blob);
          const url = new URL(src);
          console.log(url.hash);
          return blobURL + (url.hash || `#t=${from},${to}`);
        } catch (e) {
          throw e;
        }
      }));
      let media = await urls;
      let playlist = document.getElementById("playlist");
      let resolveResult;
      let result;
      const promiseResult = new Promise(resolve => resolveResult = resolve);
      document.getElementById("click")
        .addEventListener("click", async e => {
          try {
            const readableStreamControllers = new Map();
            const audioContext = new AudioContext();
            const mediaStreamDestination = audioContext.createMediaStreamDestination();
            const canvas = document.createElement("canvas");
            canvas.width = canvas.height = 0;
            document.body.appendChild(canvas);
            const canvasStream = canvas.captureStream(0);
            const [videoTrack] = canvasStream.getVideoTracks();
            const stream = [canvasStream, videoTrack].find(({
              requestFrame: rF
            }) => rF);
            mediaStreamDestination.stream.addTrack(canvasStream.getVideoTracks()[0]);
            const ctx = canvas.getContext("bitmaprenderer");
            const playlistStream = captureStream(playlist);
            const recorder = new MediaRecorder(mediaStreamDestination.stream, {
              mimeType: "video/x-matroska;codecs=avc1"
            });
            recorder.addEventListener("start", e => {
              console.log(e, e.target.stream.getTracks());
            });
            recorder.addEventListener("stop", e => {
              console.log(e);
              resolveResult(result);
            });
            recorder.addEventListener("dataavailable", e => {
              console.log(e.data);
              result = e.data;
            }, {once:true});
            recorder.addEventListener("error", e => {
              console.log(e);
            });
            recorder.addEventListener("pause", e => {
              console.log(e, e.target.stream.getTracks());
            });
            playlistStream.addEventListener("addtrack", async e => {
              console.log(e.type, e.track);
              if (e.track.kind === "video") {
                try {
                  const {
                    width, height
                  } = e.track.getSettings();
                  canvas.width = width;
                  canvas.height = height;
                  const {
                    id
                  } = e.track;
                  const imageCapture = new ImageCapture(e.track);
                  new ReadableStream({
                      async start(controller) {
                          console.log("reader start");
                          return readableStreamControllers.set(id, controller);
                        },
                        async pull(controller) {
                          if (e.track.enabled && e.track.readyState === "live") {
                            // https://github.com/w3c/mediacapture-image/issues/212
                            controller.enqueue(await imageCapture.grabFrame());
                          };
                        }
                    })
                    .pipeTo(new WritableStream({
                      write(imageBitmap) {
                        ctx.transferFromImageBitmap(imageBitmap);
                        stream.requestFrame();
                        imageBitmap.close();
                      }, close() {
                        console.log("writer close");
                      }
                    }))
                    .catch(e => {
                      throw e;
                    })
                } catch (e) {
                  console.error(e);
                }
              } else {
                const audioTrack = audioContext.createMediaStreamSource(new MediaStream([e.track]));
                audioTrack.connect(mediaStreamDestination);
              }
              if (recorder.state === "inactive") {
                recorder.start();
              } else {
                if (recorder.state === "paused") {
                  recorder.resume();
                }
              }
              e.track.addEventListener("mute", e => {
                console.log(e.type, e.track);
              });
              e.track.addEventListener("unmute", e => {
                console.log(e.type, e.track);
              });
              e.track.addEventListener("ended", e => {
                console.log(e.type, e.track);
              });
            });
            playlist.addEventListener("play", async e => {
              console.log(e, e.target.readyState);
            });
            for (const blobURL of media) {
              await new Promise(async resolve => {
                playlist.addEventListener("pause", e => {
                  console.log(e);
                  recorder.pause();
                  const currentVideoTrack = playlistStream.getVideoTracks().find(({
                    enabled
                  }) => enabled);
                  const {
                    id
                  } = currentVideoTrack;
                  currentVideoTrack.enabled = false;
                  currentVideoTrack.stop();
                  readableStreamControllers.get(id).close();
                  console.log(currentVideoTrack);
                  resolve();
                }, {
                  once: true
                });
                playlist.src = blobURL;
              });
            }
            recorder.stop();
            let blob = await promiseResult;
            [...mediaStreamDestination.stream.getTracks(), ...playlistStream.getTracks()]
            .filter(({
                enabled
              }) => enabled)
              .forEach(track => {
                track.enabled = false;
                track.stop();
              });
            await audioContext.close();
            const videoStream = document.createElement("video");
            videoStream.addEventListener("canplaythrough", e => {
              console.log(videoStream.duration);
              media.forEach(blobURL => URL.revokeObjectURL(blobURL.split("#").shift()));
            });
            videoStream.addEventListener("resize", ({target:{videoWidth, videoHeight}}) => {
              console.log(videoWidth, videoHeight);
            });
            videoStream.controls = videoStream.autoplay = true;
            videoStream.preload = "auto";
            const src = URL.createObjectURL(blob);
            document.body.appendChild(videoStream);
            videoStream.src = src;
            console.log(blob, src);
            playlist.src = "";
            playlist.remove();
            canvas.remove();
          } catch (e) {
            console.error(e);
            console.trace();
          };
        }, {
          once: true
        });
    })()
  </script>
</body>
</html>
