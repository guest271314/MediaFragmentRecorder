<!DOCTYPE html>
<html>
<head>
  <title>Record MediaStream potentially including variable width and height MediaStreamTrack with RTCPeerConnection(), RTCRtpSender.replaceTrack(), MediaRecorder(), openh264 codec, AudioWorklet, OffscreenCanvas, Worker, JavaScript Module</title>
</head>
<body>
  <video id="video" autoplay controls></video>
  <script type="module">
    // MediaStream outputting #000000 video frames and audio silence
    import {
      mediaStream, audioContext, worker
    }
    from "./export.js";
    let recorder, result;
    const video = document.getElementById("video");
    console.log(mediaStream, audioContext, worker);
    (async() => {
      const [audioTrack, videoTrack] = ["audio", "video"].map(kind => mediaStream.getTracks().find(({
        kind: trackKind
      }) => trackKind === kind));
      const fromLocalPeerConnection = new RTCPeerConnection();
      const toLocalPeerConnection = new RTCPeerConnection();
      const fromConnection = new Promise(resolve => fromLocalPeerConnection.addEventListener("icecandidate", async e => {
        console.log("from", e);
        try {
          resolve(toLocalPeerConnection.addIceCandidate(e.candidate ? e.candidate : null));
        } catch (e) {
          console.error(e);
        }
      }, {
        once: true
      }));
      const toConnection = new Promise(resolve => toLocalPeerConnection.addEventListener("icecandidate", async e => {
        console.log("to", e);
        try {
          resolve(fromLocalPeerConnection.addIceCandidate(e.candidate ? e.candidate : null));
        } catch (e) {
          console.error(e);
        }
      }, {
        once: true
      }));
      fromLocalPeerConnection.addEventListener("negotiationneeded", e => {
        console.log(e);
      });
      toLocalPeerConnection.addEventListener("negotiationneeded", e => {
        console.log(e);
      });
      const tracks = new Promise(resolve => {
        let ids = mediaStream.getTracks().map(({
            id
          }) => id),
          i = 0;
        toLocalPeerConnection.addEventListener("track", ({
          track, streams: [stream]
        }) => {
          if (ids.includes(track.id) && ++i === ids.length) {
            resolve(stream);
          }
        });
      });
      // Add initial audio and video MediaStreamTrack to PeerConnection, pass initial MediaStream
      const {
        sender: audioSender,
        receiver: audioReceiver
      } = fromLocalPeerConnection.addTransceiver(audioTrack, {
        streams: [mediaStream]
      });
      const {
        sender: videoSender,
        receiver: videoReceiver
      } = fromLocalPeerConnection.addTransceiver(videoTrack, {
        streams: [mediaStream]
      });
      console.log(audioSender, videoSender, audioReceiver, videoReceiver);
      const offer = await fromLocalPeerConnection.createOffer();
      await toLocalPeerConnection.setRemoteDescription(offer);
      await fromLocalPeerConnection.setLocalDescription(toLocalPeerConnection.remoteDescription);
      const answer = await toLocalPeerConnection.createAnswer();
      await fromLocalPeerConnection.setRemoteDescription(answer);
      await toLocalPeerConnection.setLocalDescription(fromLocalPeerConnection.remoteDescription);
      const stream = await tracks;
      video.srcObject = stream;
      // When MediaStream is not set as srcObject Blob at MediaRecorder
      // dataavailable event.data size is 0
      const urls = await Promise.all([{
        src: "https://upload.wikimedia.org/wikipedia/commons/a/a4/Xacti-AC8EX-Sample_video-001.ogv",
        from: 0,
        to: 4
      }, {
        src: "https://mirrors.creativecommons.org/movingimages/webm/ScienceCommonsJesseDylan_240p.webm#t=10,20",
        from: 10,
        to: 20
      }, {
        from: 55,
        to: 60,
        src: "https://nickdesaulniers.github.io/netfix/demo/frag_bunny.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://raw.githubusercontent.com/w3c/web-platform-tests/master/media-source/mp4/test.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4"
      }, {
        from: 0,
        to: 6,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4#t=0,6"
      }].map(async({
        from,
        to,
        src
      }) => {
        try {
          const request = await fetch(src);
          const blob = await request.blob();
          const blobURL = URL.createObjectURL(blob);
          const url = new URL(src);
          console.log(url.hash);
          return blobURL + (url.hash || `#t=${from},${to}`);
        } catch (e) {
          throw e;
        }
      }));
      const videoStream = document.createElement("video");
      videoStream.muted = true;
      videoStream.onloadedmetadata = e => {
        const {
          videoWidth: width,
          videoHeight: height
        } = e.target;
        videoStream.width = video.width = width;
        videoStream.height = video.height = height;
      }
      const ms = videoStream.captureStream();
      ms.onaddtrack = async e => {
        console.log(e.track.getSettings());
        if (e.track.kind === "audio") {
          await audioSender.replaceTrack(e.track);
        } else {
          await videoSender.replaceTrack(e.track);
        }
      }
      for (const blobURL of urls) {
        await new Promise(resolve => {
          videoStream.addEventListener("pause", async _ => {
            recorder.pause();
            resolve();
          }, {
            once: true
          });
          videoStream.addEventListener("canplay", async _ => {
            if (!recorder) {
              await new Promise(resizedPromise => {
                // handle resize event
                const handleResize = async _ => {
                  const {
                    width, height
                  } = ms.getVideoTracks()[0].getSettings();
                  console.log(video.width, width);
                  // check width and height of <video> element
                  if (video.width === width && video.height === height) {
                    console.log(video.width, width);
                    video.removeEventListener("resize", handleResize);
                    await new Promise(unmutePromise => {
                      const [track] = mediaStream.getVideoTracks();
                      let now = performance.now();
                      console.log(video.currentTime, track.muted, stream.getVideoTracks()[0].muted, ms.getVideoTracks()[0].muted);
                      // await unmute event of video track
                      track.addEventListener("unmute", async _ => {
                        console.log(_.type, (performance.now() - now) / 1000, video.currentTime, video.width, video.videoWidth, track.getSettings().width);
                        unmutePromise(await videoStream.play());
                      }, {
                        once: true
                      })
                    });
                    recorder = new MediaRecorder(stream, {
                    /*
                      https://cs.chromium.org/chromium/src/third_party/openh264/README.chromium
                      
                      Name: OpenH264
                      Short Name: openh264
                      URL: http://www.openh264.org/
                      Version: unknown
                      (Cut at 6f26bce0b1c4e8ce0e13332f7c0083788def5fdf, which is between 1.9.0 and
1.10.0)
                      License: 2-Clause BSD
                      License File: src/LICENSE
                      Security Critical: yes
                     
                      Description:
                      Cisco's H.264 video codec implementation.

                        Important:
                        While the OpenH264 source code is under BSD license, other license(s) also
                        apply for builds (MPEG-LA patent), see www.openh264.org for more information.

                      Local Modifications:
                      N/A
                    */
                      mimeType: "video/x-matroska;codecs=h264"
                    });
                    recorder.onstart = _ => {
                      console.log(_.type);
                    }
                    result = new Promise(resolve => {
                      recorder.addEventListener("dataavailable", ({
                        data
                      }) => {
                        resolve(data);
                      }, {
                        once: true
                      })
                    });
                    recorder.start();
                    resizedPromise();
                  }
                }
                video.addEventListener("resize", handleResize);
              });
            } else {
              await videoStream.play();
              recorder.resume();
            }
          }, {
            once: true
          });
          videoStream.src = blobURL;
        });
      }
      recorder.stop();
      let blob = await result;
      let blobURL = URL.createObjectURL(blob);
      await audioContext.close();
      worker.terminate();
      [mediaStream.getTracks(), stream.getTracks(), ms.getTracks()].flat()
        .forEach(track => {
          track.enabled = false;
          track.stop();
          console.log(track);
        });
      video.srcObject = null;
      video.remove();
      videoStream.src = "";
      videoStream.remove();
      const recordedVideo = document.createElement("video");
      document.body.appendChild(recordedVideo);
      recordedVideo.autoplay = recordedVideo.controls = true;
      recordedVideo.onresize = ({
        target: {
          videoWidth, videoHeight
        }
      }) => {
        console.log(videoWidth, videoHeight);
      };
      recordedVideo.src = blobURL;
    })();
  </script>
</body>
</html>
