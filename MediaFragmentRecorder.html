<!DOCTYPE html>
<html>
<head>
  <title>Record media fragments to single webm video using getDisplayMedia(), AudioContext(), window.open(), MediaRecorder()</title>
</head>
<body>
  <h1 id="click">open window</h1>
  <script>
    const click = document.getElementById("click"); 

    const mediaFragmentRecorder = ({
      width = 320, height = 240
    } = {}) => (async() => {
      try {
        click.textContent = "fetching media resources";
        const html = `<!DOCTYPE html>
                        <html>
                          <head>
                            <title>getDisplayMedia</title>
                            <style>
                              * {padding:0;margin:0;overflow:hidden;}
                              #video {cursor:none;object-fit:cover;object-position:50% 50%;}
                              video::-webkit-media-controls,audio::-webkit-media-controls {display:none !important;}
                            </style>
                          </head>
                          <body tabIndex="1">
                            <!-- Chromium: To not record location and title bars check if "TEMPORARY" is in window, if true add 30 to height -->
                            <video id="video" width="${width}" height="${height + 30}"></video>
                          </body>
                        </html>`;

        const blobURL = URL.createObjectURL(new Blob([html], {
          type: "text/html"
        }));

        let result;
        const promise = new Promise(resolve => result = resolve);
        // Firefox: To not record location and title bars set dom.disable_window_open_feature.location at "about:preferences"
        // Chromium: To not record location and title bars check if "TEMPORARY" is in window, if true add 30 to height
        // Select window named "getDisplayMedia"
        const mediaWindow = window.open(blobURL, "getDisplayMedia", `width=${width},height=${height + ("TEMPORARY" in window ? 30 : 0)}`);

        mediaWindow.addEventListener("load", async e => {
          console.log(e.target, e.currentTarget, mediaWindow);
          const mediaDocument = mediaWindow.document;
          mediaDocument.designMode = "on";
          const videoStream = mediaDocument.getElementById("video");

          let media = await Promise.all([{
            src: "https://upload.wikimedia.org/wikipedia/commons/a/a4/Xacti-AC8EX-Sample_video-001.ogv",
            from: 0,
            to: 4
          }, {
            src: "https://mirrors.creativecommons.org/movingimages/webm/ScienceCommonsJesseDylan_240p.webm#t=10,20"
          }, {
            from: 55,
            to: 60,
            src: "https://nickdesaulniers.github.io/netfix/demo/frag_bunny.mp4"
          }, {
            from: 0,
            to: 5,
            src: "https://raw.githubusercontent.com/w3c/web-platform-tests/master/media-source/mp4/test.mp4"
          }, {
            from: 0,
            to: 5,
            src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"
          }, {
            from: 0,
            to: 5,
            src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4"
          }, {
            src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4#t=0,6"
          }].map(async({...props
          }) => {
            const {
              src
            } = props;
            const blob = (await (await fetch(src)).blob());
            return {
              blob,
              ...props
            }
          }));
          
          mediaWindow.addEventListener("click", async e => {
            const blobURLs = [];
            const context = new AudioContext();
            const mediaStream = context.createMediaStreamDestination();
            const [audioTrack] = mediaStream.stream.getAudioTracks();
            const [videoTrack] = displayStream.getVideoTracks();

            await videoTrack.applyConstraints({
              cursor: "never", // https://github.com/web-platform-tests/wpt/issues/16206
              width,
              height,
              aspectRatio: 1.33,
              resizeMode: "crop-and-scale"
            });

            videoTrack.contentHint = "motion";
            videoTrack.cursor = "never";

            displayStream.addTrack(audioTrack);
            console.log(videoTrack, videoTrack.getSettings(), videoTrack.getConstraints());
            const source = context.createMediaElementSource(videoStream);
            source.connect(context.destination);
            source.connect(mediaStream);

            [videoTrack, audioTrack].forEach(track => {
              track.onended = e => console.log(e);
            });

            const recorder = new MediaRecorder(displayStream, {
              mimeType: "video/webm;codecs=vp8,opus"
            });
            recorder.addEventListener("start", e => {
              console.log(e);
              mediaDocument.title = click.textContent = "recording";
            });
            recorder.addEventListener("error", e => {
              throw e;
            });
            recorder.addEventListener("dataavailable", async e => {
              console.log(e.data);
              result(new Uint8Array(await new Response(e.data).arrayBuffer()));
            });
            recorder.addEventListener("stop", async e => {
              try {
                click.textContent = "";
                [videoTrack, audioTrack].forEach(track => {
                  track.enabled = false;
                  track.stop();
                });
                await context.close();
                mediaWindow.close();
                blobURLs.forEach(blobURL => URL.revokeObjectURL(blobURL));
                console.log(e, videoTrack, audioTrack);
              } catch (e) {
                console.error(e);
              }
            });
            videoStream.addEventListener("loadedmetadata", async e => {
              console.log(e);
              try {
                await videoStream.play();
              } catch (e) {
                throw e;
              }
            });
            try {
              for (let {
                  from,
                  to,
                  src,
                  blob
                }
                of media) {
                await new Promise(resolve => {
                  const url = new URL(src);
                  if (url.hash.length) {
                    [from, to] = url.hash.match(/\d+|\d+\.\d+/g).map(Number);
                  }
                  const blobURL = URL.createObjectURL(blob);
                  blobURLs.push(blobURL);
                  videoStream.addEventListener("play", e => {
                    if (recorder.state === "inactive") {
                      recorder.start()
                    } else {
                      if (recorder.state === "paused") {
                        recorder.resume();
                      }
                    }
                  }, {
                    once: true
                  });

                  videoStream.addEventListener("pause", e => {
                    if (recorder.state === "recording") {
                      recorder.pause();
                    }
                    resolve();
                  }, {
                    once: true
                  });
                  videoStream.src = `${blobURL}#t=${from},${to}`;
                })
              }
              recorder.stop();
              console.log(videoTrack, videoTrack.getSettings(), videoTrack.getConstraints());
            } catch (e) {
              throw e;
            }
          }, {
            once: true
          });

          const displayStream = await navigator.mediaDevices.getDisplayMedia({
            video: {cursor:"never"}
          });

          click.textContent = "click getDisplayMedia window to start recording";
          mediaDocument.title = "getDisplayMedia";

          console.log(displayStream, displayStream.getTracks()[0].getSettings());
        });

        const mediaBuffer = await promise;
        console.log(mediaBuffer);
        const video = document.createElement("video");
        video.controls = true;
        document.body.appendChild(video);
        video.addEventListener("loadedmetadata", e => console.log(e.target.videoWidth, e.target.videoHeight));
        video.src = URL.createObjectURL(new Blob([mediaBuffer]));
      } catch (e) {
        console.error(e);
        console.trace();
      }
    })();

    click.addEventListener("click", e => {
      mediaFragmentRecorder();
    }, {
      once: true
    });
  </script>
</body>
</html>
