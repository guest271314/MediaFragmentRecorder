<!DOCTYPE html>
<html>
<head>
  <title>Record media fragments to single media file using HTMLMediaElement.captureStream(), MediaStream addtrack event, ImageCapture(), canvas.captureStream(), ReadableStream(), WritableStream(), AudioContext(), MediaRecorder()</title>
</head>
<body>
  <h1 id="click">click</h1>
  <video id="playlist" src="" controls="true" autoplay="true"></video>
  <script>
    (async() => {
      const captureStream = mediaElement =>
        "mozCaptureStream" in mediaElement ? mediaElement.mozCaptureStream() : mediaElement.captureStream();
      const width = 320;
      const height = 240;
      const videoConstraints = {
        resizeMode: "crop-and-scale",
        width,
        height
      };
      const blobURLS = [];
      const urls = Promise.all([{
        src: "https://upload.wikimedia.org/wikipedia/commons/a/a4/Xacti-AC8EX-Sample_video-001.ogv",
        from: 0,
        to: 4
      }, {
        from: 10,
        to: 20,
        src: "https://mirrors.creativecommons.org/movingimages/webm/ScienceCommonsJesseDylan_240p.webm#t=10,20"
      }, {
        from: 55,
        to: 60,
        src: "https://nickdesaulniers.github.io/netfix/demo/frag_bunny.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://raw.githubusercontent.com/w3c/web-platform-tests/master/media-source/mp4/test.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"
      }, {
        from: 0,
        to: 5,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4"
      }, {
        from: 0,
        to: 6,
        src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4#t=0,6"
      }].map(async({
        from,
        to,
        src
      }) => {
        try {
          const request = await fetch(src);
          const blob = await request.blob();
          const blobURL = URL.createObjectURL(blob);
          blobURLS.push(blobURL);
          const url = new URL(src);
          console.log(url.hash);
          return blobURL + (url.hash || `#t=${from},${to}`);
        } catch (e) {
          throw e;
        }
      }));
      let media = await urls;
      let playlist = document.getElementById("playlist");
      playlist.width = width;
      playlist.height = height;
      let resolveResult;
      let result;
      const promiseResult = new Promise(resolve => resolveResult = resolve);
      document.getElementById("click")
        .addEventListener("click", async e => {
          try {
            const audioContext = new AudioContext();
            const mediaStreamDestination = audioContext.createMediaStreamDestination();
            const [audioTrack] = mediaStreamDestination.stream.getAudioTracks();
            mediaStreamDestination.connect(audioContext.destination);
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            document.body.appendChild(canvas);
            const canvasStream = canvas.captureStream(0);
            mediaStreamDestination.stream.addTrack(canvasStream.getVideoTracks()[0]);
            const ctx = canvas.getContext("bitmaprenderer");
            const playlistStream = captureStream(playlist);
            const recorder = new MediaRecorder(mediaStreamDestination.stream, {
              mimeType: "video/x-matroska;codecs=avc1"
            });
            recorder.addEventListener("start", e => {
              console.log(e, e.target.stream.getTracks());
            });
            recorder.addEventListener("stop", e => {
              console.log(e);
              resolveResult(result);
            });
            recorder.addEventListener("dataavailable", e => {
              console.log(e.data);
              result = e.data;
            });
            recorder.addEventListener("error", e => {
              console.log(e);
            });
            recorder.addEventListener("pause", e => {
              console.log(e, e.target.stream.getTracks());
            });
            playlistStream.addEventListener("addtrack", async e => {
              console.log(e.type, e.track);
              if (e.track.kind === "video") {
                try {
                  await e.track.applyConstraints(videoConstraints);
                  const imageCapture = new ImageCapture(e.track);
                  new ReadableStream({
                      async pull(controller) {
                        if (e.track.enabled && e.track.readyState === "live") {
                          controller.enqueue(await imageCapture.grabFrame());
                        } else {
                          controller.close();
                        }
                      }
                    })
                    .pipeTo(new WritableStream({
                      write(imageBitmap) {
                          ctx.transferFromImageBitmap(imageBitmap);
                          if ("requestFrame" in canvasStream) {
                            canvasStream.requestFrame()
                          } else {
                            canvasStream.getVideoTracks()[0].requestFrame()
                          }
                        }
                    }))
                    .catch(e => {
                      throw e;
                    })
                } catch (e) {
                  console.error(e, e.name === "OverconstrainedError");
                }
              } else {
                const audioTrack = audioContext.createMediaStreamSource(new MediaStream([e.track]));
                audioTrack.connect(mediaStreamDestination);
              }
              if (recorder.state === "inactive") {
                recorder.start();
              } else {
                if (recorder.state === "paused") {
                  recorder.resume();
                }
              }
              e.track.addEventListener("mute", e => {
                console.log(e.type, e.track);
              });
              e.track.addEventListener("unmute", e => {
                console.log(e.type, e.track);
              });
              e.track.addEventListener("ended", e => {
                console.log(e.type, e.track);
              });
            });
            playlist.addEventListener("play", async e => {
              console.log(e, e.target.readyState);
            });
            for (const blobURL of media) {
              await new Promise(async resolve => {
                playlist.addEventListener("pause", e => {
                  console.log(e);
                  recorder.pause();
                  const currentVideoTrack = playlistStream.getVideoTracks().find(({enabled}) => enabled);
                  currentVideoTrack.enabled = false;
                  currentVideoTrack.stop();
                  console.log(currentVideoTrack);
                  resolve();
                }, {
                  once: true
                });
                playlist.src = blobURL;
              });
            }
            recorder.stop();
            let blob = await promiseResult;
            blobURLS.forEach(blobURL => URL.revokeObjectURL(blobURL));
            mediaStreamDestination.stream.getTracks()
              .forEach(track => {
                track.enabled = false;
                track.stop();
                console.log(track);
              });
            await audioContext.close();
            console.log(blob);
            playlist.remove();
            canvas.remove();
            const videoStream = document.createElement("video");
            videoStream.addEventListener("canplaythrough", e => {
              console.log(videoStream.duration, videoStream.buffered.end(0));
            });
            videoStream.width = width;
            videoStream.height = height;
            videoStream.controls = true;
            document.body.appendChild(videoStream);
            videoStream.src = URL.createObjectURL(blob);
          } catch (e) {
            console.error(e);
            console.trace();
          };
        }, {
          once: true
        });
    })()
  </script>
</body>
</html>
