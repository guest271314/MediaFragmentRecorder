<!DOCTYPE html>
<html>
<head>
  <title>Record media fragments to single webm video using canvas.captureStream(), requestAnimationFrame(), AudioContext.createMediaStreamDestination(), AudioContext.createMediaElementSource(), MediaRecorder()</title>
</head>
<body>
  <h1>click</h1>
  <script>
    // Based on approaches at https://stackoverflow.com/a/39302994, https://stackoverflow.com/a/45343042
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.globalCompositeOperation = "copy";
    document.body.appendChild(canvas);
    const video = document.createElement("video");
    video.controls = true;
    document.body.appendChild(video);
    let ended = false;
    let playing = false;
    let raf = void 0;
    let width = 0;
    let height = 0;
    const draw = _ => {
      if (ended && !playing) {
        cancelAnimationFrame(raf);
        console.log("raf ended");
        return;
      }
      ctx.drawImage(video, 0, 0, width, height);
      raf = requestAnimationFrame(draw)
    }
    let urls = [{
      src: "https://upload.wikimedia.org/wikipedia/commons/a/a4/Xacti-AC8EX-Sample_video-001.ogv",
      from: 0,
      to: 4
    }, {
      src: "https://mirrors.creativecommons.org/movingimages/webm/ScienceCommonsJesseDylan_240p.webm#t=10,20"
    }, {
      from: 55,
      to: 60,
      src: "https://nickdesaulniers.github.io/netfix/demo/frag_bunny.mp4"
    }, {
      from: 0,
      to: 5,
      src: "https://raw.githubusercontent.com/w3c/web-platform-tests/master/media-source/mp4/test.mp4"
    }, {
      from: 0,
      to: 5,
      src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"
    }, {
      from: 0,
      to: 5,
      src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4"
    }, {
      src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4#t=0,6"
    }];
    document.querySelector("h1")
      .addEventListener('click', e => {
        (async() => {
          let done;
          const promise = new Promise(resolve => done = resolve);
          urls = await Promise.all(urls.map(async({...props
          }) => {
            const {
              src
            } = props;
            const blob = (await (await fetch(src)).blob());
            return {
              blob, ...props
            }
          }));
          const canvasStream = canvas.captureStream(60);
          const context = new AudioContext();
          const mixedAudio = context.createMediaStreamDestination();
          const [videoTrack, audioTrack] = [canvasStream.getVideoTracks()[0], mixedAudio.stream.getAudioTracks()[0]];
          [videoTrack, audioTrack]
          .forEach(track => {
            track.addEventListener("ended", e => console.log(e))
          });
          context.onstatechange = e => console.log(e, e.target.state);
          const mediaStream = new MediaStream([videoTrack, audioTrack]);
          mediaStream.addEventListener("ended", e => console.log(e));
          video.addEventListener("playing", e => {
            playing = true;
          });
          const source = context.createMediaElementSource(video);
          source.connect(context.destination);
          source.connect(mixedAudio);
          const recorder = new MediaRecorder(mediaStream, {
            mimeType: "video/webm;codecs=vp8,opus"
          });
          recorder.addEventListener("error", e => {
            console.error(e)
          });
          recorder.addEventListener("dataavailable", e => {
            console.log(e.data);
            done(e.data);
          });
          recorder.addEventListener("stop", e => {
            console.log(e);
            [videoTrack, audioTrack].forEach(track => track.stop());
            video.src = "";
            video.load();
            context.close();
            video.remove();
            canvas.remove();
          });
          video.addEventListener("loadedmetadata", e => {
            width = canvas.width = video.videoWidth;
            height = canvas.height = video.videoHeight;
          });
          video.addEventListener("canplay", e => {
            if (raf === undefined) {
              raf = requestAnimationFrame(draw);
              recorder.start();
            }
            video.play().catch(e => {
              throw e
            });
          });
          try {
            for (let [index, {
                from, to, src, blob
              }] of urls.entries()) {
              await new Promise(resolve => {
                const url = new URL(src);
                if (url.hash.length) {
                  [from, to] = url.hash.match(/\d+|\d+\.\d+/g).map(Number);
                }
                console.log(from, to);
                const blobURL = URL.createObjectURL(blob);
                video.addEventListener("pause", e => {
                  playing = false;
                  resolve();
                  console.log(video.currentTime);
                }, {
                  once: true
                });
                video.src = `${blobURL}#t=${from},${to}`;
              })
            }
            ended = true;
            playing = false;
            if (recorder.state === "recording") {
              console.log(recorder.state);
              recorder.stop();
              cancelAnimationFrame(raf);
            }
            return promise;
          } catch (e) {
            console.error(e);
          }
        })()
        .then(blob => {
            const display = document.createElement("video");
            display.controls = true;
            display.preload = "auto";
            display.addEventListener("canplaythrough", e => {
              display.play().catch(console.error)
            }, {
              once: true
            });
            const src = URL.createObjectURL(blob);
            display.src = src;
            document.body.appendChild(display);
            console.log(blob, src);
          })
          .catch(console.error)
      })
  </script>
</body>
</html>
